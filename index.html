<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Roster to ICS Exporter</title>
    <style>
        /* Your existing CSS */
        * { box-sizing: border-box; }

        body {
            font-family: sans-serif;
            margin: 1em;
            background: #f8f8f8;
            overflow-x: hidden;
            position: relative;
        }

        .logo {
            text-align: center;
            margin-bottom: 10px;
        }

        .logo img {
            max-width: 180px;
            height: auto;
            margin-top: 10px;
            margin-bottom: 10px;
            box-shadow: 0 0 8px rgba(0,0,0,0.05);
        }

        .top-controls {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        .dark-toggle-btn {
            padding: 0.6em 1em;
            font-size: 1em;
            font-weight: bold;
            border: 1px solid #ccc;
            background: #eee;
            cursor: pointer;
            border-radius: 6px;
        }

        hr.divider {
            max-width: 200px;
            margin: 0 auto 20px auto;
            border: 0;
            border-top: 1px solid #ccc;
        }

        .container {
            max-width: 1000px;
            margin: auto;
            background: #fff;
            padding: 1em;
            box-shadow: 0 0 10px #ccc;
            border-radius: 8px;
        }

        textarea {
            width: 100%;
            height: 350px;
            max-width: 100%;
            display: block;
            font-family: monospace;
            padding: 1em;
            border: 1px solid #ccc;
            resize: vertical;
            font-size: 14px;
            line-height: 1.5;
        }

        button {
            margin: 0.5em 0.5em 0 0;
            padding: 0.6em 1.2em;
            font-size: 1em;
            cursor: pointer;
            border-radius: 6px; /* Added for consistency */
            border: 1px solid #ccc; /* Added for consistency */
            background: #eee; /* Added for consistency */
        }

        button:hover {
            background-color: #e0e0e0; /* Added hover effect */
        }

        table#printTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
            display: none;
        }

        table#printTable, table#printTable th, table#printTable td {
            border: 1px solid #333;
        }

        table#printTable th, table#printTable td {
            padding: 2px 4px;
            font-size: 9pt;
            text-align: left;
            vertical-align: top;
            white-space: pre-wrap;
        }

        .weekend-row {
            background-color: #e0e0e0 !important;
        }

        #breachResults {
            margin-top: 1em;
            padding: 1em;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 5px;
            max-height: 200px; /* Limit height for scroll if many breaches */
            overflow-y: auto; /* Enable scrolling if content exceeds max-height */
            display: none; /* Hidden by default, shown when results are available */
        }

        #breachResults h3 {
            margin-top: 0;
            color: #333;
        }

        #breachResults ul {
            list-style-type: none;
            padding: 0;
        }

        #breachResults li {
            margin-bottom: 0.5em;
            font-weight: bold;
            color: #d9534f; /* Red for breaches */
        }

        #breachResults li.no-breach {
            color: #5cb85c; /* Green for no breaches */
        }

        @media print {
            .logo, .top-controls, textarea, button, hr.divider, #breachResults {
                display: none !important;
            }

            body {
                background: white;
                margin: 0;
            }

            .container {
                box-shadow: none;
                padding: 0;
                max-width: 100%;
            }

            table#printTable {
                display: table;
            }

            .weekend-row {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: #e0e0e0 !important;
            }
        }

        /* Dark mode styles */
        body.dark-mode {
            background: #121212;
            color: #f0f0f0;
        }

        body.dark-mode .container {
            background: #1e1e1e;
            box-shadow: 0 0 10px #000;
        }

        body.dark-mode textarea {
            background: #2a2a2a;
            color: #f0f0f0;
            border: 1px solid #555;
        }

        body.dark-mode button,
        body.dark-mode .dark-toggle-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
        }

        body.dark-mode button:hover {
            background-color: #555;
        }

        body.dark-mode table#printTable {
            background: #1e1e1e;
            color: #f0f0f0;
        }

        body.dark-mode table#printTable th,
        body.dark-mode table#printTable td {
            border-color: #555;
        }

        body.dark-mode .weekend-row {
            background-color: #2f2f2f !important;
        }

        body.dark-mode #breachResults {
            background-color: #2a2a2a;
            border-color: #555;
        }

        body.dark-mode #breachResults h3 {
            color: #f0f0f0;
        }

        body.dark-mode #breachResults li {
            color: #ff9999; /* Lighter red for dark mode breaches */
        }
    </style>
</head>
<body>
    <div class="logo">
        <img src="alliance-logo.png" alt="Alliance Airlines Logo">
    </div>
    <hr class="divider">

    <div class="top-controls">
        <button class="dark-toggle-btn" onclick="toggleDarkMode()" id="darkModeBtn">Switch to Dark Mode</button>
    </div>

    <div class="container">
        <textarea id="rosterInput" placeholder="Paste your roster here..."></textarea><br/>
        <button onclick="generatePrintout()">Print This Page</button>
        <button onclick="generateICS()">Download ICS File</button>
        <button onclick="checkForBreaches()">Check for Roster Breaches</button> <div id="breachResults">
            <h3>Roster Breach Check Results:</h3>
            <ul id="breachList">
                </ul>
        </div>

        <table id="printTable">
            <thead>
                <tr>
                    <th>Duty Date</th>
                    <th>Duty</th>
                    <th>Brief</th>
                    <th>Debrief</th>
                    <th>Layover</th>
                    <th>Details</th>
                    <th>Duty</th>
                    <th>Flight</th>
                    <th>Pax</th>
                    <th>Credit</th>
                </tr>
            </thead>
            <tbody id="printTableBody"></tbody>
        </table>
    </div>

    <script>
        function toggleDarkMode() {
            const body = document.body;
            const btn = document.getElementById('darkModeBtn');
            const isDark = body.classList.toggle('dark-mode');
            btn.textContent = isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode';
            localStorage.setItem('darkMode', isDark ? 'dark' : 'light');
        }

        window.onload = function () {
            const saved = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const shouldDark = saved === 'dark' || (!saved && prefersDark);
            if (shouldDark) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeBtn').textContent = 'Switch to Light Mode';
            }
        };

        function pad(n) {
            return n.toString().padStart(2, '0');
        }

        function cleanHeaderLines(lines) {
            const knownHeaders = [
                'Duty Date\tDuty\tBrief Time\tDebrief Time\tLayover\tDetails\tDuty hours\tFlight hours\tPax Hours\tCredit Hours',
                'Duty	Date	Duty	Brief	Time	Debrief	Time	Layover' // Added the one that sometimes appears with more spaces
            ];
            return lines.filter(line =>
                !knownHeaders.some(h =>
                    line.replace(/\s+/g, '').includes(h.replace(/\s+/g, ''))
                )
            );
        }

        function generateICS() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) return alert("Paste your roster first.");
            lines = cleanHeaderLines(lines);

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [], events = [];

            function flushRow() {
                if (!buffer.length) return;
                const row = Array(10).fill('');
                const start = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < start.length && i < 5; i++) row[i] = start[i];

                const [dd, mon, yyyy] = row[0].split(/[\/\s]/);
                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const d = new Date(Number(yyyy), months[mon], Number(dd)); // Ensure year is number

                const brief = row[2] || '00:00';
                const debrief = row[3] || '00:00';
                const duty = row[1];
                const details = buffer.slice(1).join(' | '); // Use buffer.slice(1) to get all detail lines
                const formatTime = (t) => t.replace(/:/g, '') + '00';

                const dtStart = yyyy + pad(d.getMonth() + 1) + pad(d.getDate()) + 'T' + formatTime(brief);
                const dtEnd = yyyy + pad(d.getMonth() + 1) + pad(d.getDate()) + 'T' + formatTime(debrief);

                events.push(`BEGIN:VEVENT\nSUMMARY:${duty} ${brief} ${details}\nDTSTART;TZID=Australia/Brisbane:${dtStart}\nDTEND;TZID=Australia/Brisbane:${dtEnd}\nDESCRIPTION:Brief: ${brief} | ${details}\nUID:roster-${dtStart}@roster.local\nDTSTAMP:${dtStart}Z\nEND:VEVENT`);
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line)) flushRow();
                buffer.push(line);
            });
            flushRow();

            const ics = `BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\nMETHOD:PUBLISH\nX-WR-TIMEZONE:Australia/Brisbane\nBEGIN:VTIMEZONE\nTZID:Australia/Brisbane\nBEGIN:STANDARD\nDTSTART:19700101T000000\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1000\nTZNAME:AEST\nEND:STANDARD\nEND:VTIMEZONE\n${events.join('\n')}\nEND:VCALENDAR`;

            const blob = new Blob([ics.replace(/\n/g, "\r\n")], { type: 'text/calendar' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'roster_export.ics';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // --- Start of new breach checking functionality ---

        function parseTime(timeStr) {
            // Handles cases where time might be missing or invalid
            if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
                return NaN; // Indicate invalid time
            }
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes; // Return total minutes from midnight
        }

        function formatMinutesToHHMM(totalMinutes) {
            if (isNaN(totalMinutes)) return 'Invalid Time';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        // Helper function to parse roster data into a structured format
        function parseRosterData() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) {
                alert("Please paste your roster first.");
                return null;
            }
            lines = cleanHeaderLines(lines);

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [];
            const rosterEntries = [];

            function processBuffer() {
                if (!buffer.length) return;

                const rowData = Array(10).fill('');
                // First line of the buffer contains the primary data (Date, Duty, Brief, Debrief, Layover)
                const initialSplit = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < initialSplit.length && i < 5; i++) rowData[i] = initialSplit[i];

                const [dayStr, monStr, yearStr] = rowData[0].split(/[\/\s]/);
                // Handle cases where year might not be present or valid in the date string (e.g., if only DD/MON is provided)
                let currentYear = new Date().getFullYear(); // Default to current year
                if (yearStr && !isNaN(Number(yearStr))) {
                     currentYear = Number(yearStr);
                }

                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const date = new Date(currentYear, months[monStr], Number(dayStr));


                let summaryParts = [];
                // Find the line that looks like a time summary (e.g., "9:20 6:10 0:00 6:10")
                const summaryIndex = buffer.findIndex(l => timeSummaryRegex.test(l));
                if (summaryIndex !== -1) {
                    summaryParts = buffer[summaryIndex].split(/\t| {2,}/);
                    buffer.splice(summaryIndex, 1); // Remove summary line from buffer to not include in details
                }

                // The rest of the buffer lines (after the first and excluding summary) are the details
                rowData[5] = buffer.slice(1).join('\n'); // Join remaining lines for 'details'
                for (let i = 0; i < summaryParts.length; i++) rowData[6 + i] = summaryParts[i]; // Duty, Flight, Pax, Credit hours

                rosterEntries.push({
                    date: date,
                    dateString: rowData[0],
                    dutyType: rowData[1] ? rowData[1].trim() : '', // Trim whitespace
                    briefTime: rowData[2] ? rowData[2].trim() : '',
                    debriefTime: rowData[3] ? rowData[3].trim() : '',
                    layover: rowData[4] ? rowData[4].trim() : '',
                    details: rowData[5] ? rowData[5].trim() : '',
                    dutyHours: rowData[6] ? rowData[6].trim() : '',
                    flightHours: rowData[7] ? rowData[7].trim() : '',
                    paxHours: rowData[8] ? rowData[8].trim() : '',
                    creditHours: rowData[9] ? rowData[9].trim() : ''
                });
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line) && buffer.length > 0) {
                    processBuffer();
                }
                buffer.push(line);
            });
            processBuffer(); // Process the last buffer

            return rosterEntries;
        }


        function checkForBreaches() {
            const roster = parseRosterData();
            if (!roster) {
                document.getElementById('breachResults').style.display = 'none';
                return;
            }

            const breachList = document.getElementById('breachList');
            breachList.innerHTML = ''; // Clear previous results
            const breachesFound = [];

            // Helper to add breach messages
            function addBreach(message) {
                breachesFound.push(message);
                const li = document.createElement('li');
                li.textContent = message;
                breachList.appendChild(li);
            }

            // --- Implement Breach Checks ---

            // Current date context for phased RDO/Grey Day rules
            // NOTE: For a real-world application, "Commencement Date" and "Additional RDO Date"
            // should be configured accurately, perhaps as constants.
            // Using a fixed current date for testing this specific roster input.
            const today = new Date('2025-06-17T12:00:00'); // Set a fixed date for consistent testing
            const commDate = new Date('2025-03-14T00:00:00');
            const firstGreyDayImplDate = new Date('2025-05-26T00:00:00');
            const secondGreyDayImplDate = new Date('2025-08-18T00:00:00');

            let requiredRDOs = 8;
            let requiredGreyDays = 0;

            if (today >= firstGreyDayImplDate && today < secondGreyDayImplDate) {
                requiredGreyDays = 1;
            } else if (today >= secondGreyDayImplDate) {
                // This is a simplified transition. "Additional RDO Date" is complex.
                // For demonstration, let's assume if past secondGreyDayImplDate, we check for 9 RDOs + 1 Grey.
                requiredRDOs = 9;
                requiredGreyDays = 1;
            }


            // 1. Minimum RDOs and Grey Days check (per 28-day roster period)
            // This requires identifying roster periods correctly. For this example,
            // we'll treat the entire input as one roster, but note the limitation.
            let rdoCount = 0;
            let greyDayCount = 0;
            let rosterPeriodStartDate = roster.length > 0 ? roster[0].date : null; // Start date of current roster data
            let rosterPeriodEndDate = roster.length > 0 ? roster[roster.length - 1].date : null;

            // Only count if within the same roster period for the purpose of the 28-day count
            // This is a simplification and needs proper roster period detection for exact compliance.
            roster.forEach(entry => {
                if (entry.dutyType.toUpperCase().includes('RDO')) {
                    rdoCount++;
                }
                if (entry.dutyType.toUpperCase().includes('GREY DAY')) {
                    greyDayCount++;
                }
            });

            // This check is a general count over the provided roster, not necessarily a single 28-day period.
            // For robust checking, you'd need to identify 28-day blocks.
            if (roster.length > 20) { // Arbitrary check for "enough data to simulate a period"
                if (rdoCount < requiredRDOs) {
                    addBreach(`RDOs Breach: Only ${rdoCount} RDOs found. Minimum required is ${requiredRDOs} based on current date context.`);
                }
                if (greyDayCount < requiredGreyDays) {
                    addBreach(`Grey Days Breach: Only ${greyDayCount} Grey Days found. Minimum required is ${requiredGreyDays} based on current date context.`);
                }
            } else {
                // If roster is too short, we can't definitively check 28-day requirements
                // addBreach("RDO/Grey Day check: Roster input is shorter than a standard 28-day period, precise check not possible.");
            }


            // 2. Weekend Off check
            let hasWeekendOff = false;
            let currentWeekendRDOs = 0; // Tracks consecutive RDOs (Sat, Sun)
            let lastDayWasSaturdayRDO = false;

            for (let i = 0; i < roster.length; i++) {
                const entry = roster[i];
                const dayOfWeek = entry.date.getDay(); // 0 for Sunday, 6 for Saturday

                if (entry.dutyType.toUpperCase().includes('RDO')) {
                    if (dayOfWeek === 6) { // Saturday RDO
                        lastDayWasSaturdayRDO = true;
                    } else if (dayOfWeek === 0 && lastDayWasSaturdayRDO) { // Sunday RDO after a Saturday RDO
                        hasWeekendOff = true;
                        break; // Found a weekend off, stop checking
                    } else {
                        lastDayWasSaturdayRDO = false; // Reset if RDO is not Saturday or Sunday
                    }
                } else {
                    lastDayWasSaturdayRDO = false; // Reset if not an RDO
                }
            }

            if (!hasWeekendOff) {
                addBreach("Weekend Off Breach: At least one weekend (Saturday and Sunday as RDOs) free of all duty is required per roster period.");
            }


            // 3. Consecutive Duty Tours (6 days max, then 2 days off)
            let consecutiveDutyDays = 0;
            let lastDayOffCount = 0; // Number of consecutive RDO/Grey days

            for (let i = 0; i < roster.length; i++) {
                const entry = roster[i];
                const isDayOff = entry.dutyType.toUpperCase().includes('RDO') || entry.dutyType.toUpperCase().includes('GREY DAY');

                if (isDayOff) {
                    consecutiveDutyDays = 0; // Reset duty counter
                    lastDayOffCount++;
                } else {
                    consecutiveDutyDays++;
                    lastDayOffCount = 0; // Reset day off counter

                    if (consecutiveDutyDays > 6) {
                        // This means the current day is the 7th+ consecutive duty day.
                        // We need to check if the break *before* this streak was sufficient.
                        // The rule is "without a minimum of two (2) consecutive days off".
                        // This check needs context of the days *before* the streak started.
                        // It's more complex than a simple `lastDayOffCount` here.

                        // Let's re-think this check for clarity and accuracy based on the rule.
                        // Rule: "not rostered to work two (2) consecutive tours of duty that each consist of six (6) consecutive days without a minimum of two (2) consecutive days off"
                        // This implies that after 6 consecutive days, you *must* have 2 days off before starting another potential 6-day tour.

                        // A simpler check might be: if current duty day extends a streak beyond 6, AND the last break before this extended streak was less than 2 days.
                        let streakStart = i - consecutiveDutyDays + 1; // Index of the start of the current streak
                        let daysOffBeforeStreak = 0;
                        if (streakStart > 0) { // Only check if there are days before the streak
                            for (let j = streakStart - 1; j >= 0; j--) {
                                const prevEntry = roster[j];
                                const prevIsDayOff = prevEntry.dutyType.toUpperCase().includes('RDO') || prevEntry.dutyType.toUpperCase().includes('GREY DAY');
                                if (prevIsDayOff) {
                                    daysOffBeforeStreak++;
                                } else {
                                    break; // Found a duty day, break the count of days off
                                }
                            }
                        }

                        if (consecutiveDutyDays > 6 && daysOffBeforeStreak < 2) {
                            addBreach(`Consecutive Duty Tours Breach: On ${entry.dateString}, pilot is on their ${consecutiveDutyDays}th consecutive duty day. This exceeds 6 consecutive days without a preceding break of at least 2 consecutive days off.`);
                        }
                    }
                }
            }


            // 4. Maximum Number of Early Starts (3 starts before 0600 in any 7-day period)
            const earlyStartsThreshold = 3;
            const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
            const SIX_AM_IN_MINUTES = parseTime('06:00');

            for (let i = 0; i < roster.length; i++) {
                const currentEntry = roster[i];
                const currentBriefTimeMinutes = parseTime(currentEntry.briefTime);

                // Only consider actual duties (not RDO, GREY DAY, SBY, LEAVE) for early starts
                const isActualDuty = !(currentEntry.dutyType.toUpperCase().includes('RDO') ||
                                       currentEntry.dutyType.toUpperCase().includes('GREY DAY') ||
                                       currentEntry.dutyType.toUpperCase().includes('SBY') || // Exclude Standby
                                       currentEntry.dutyType.toUpperCase().includes('LEAVE') ||
                                       isNaN(currentBriefTimeMinutes) // Exclude entries with invalid brief times
                                      );

                if (isActualDuty && currentBriefTimeMinutes < SIX_AM_IN_MINUTES) {
                    let earlyStartsInWindow = 0;
                    const windowStartTime = currentEntry.date.getTime() - sevenDaysInMs; // Start of the 7-day window (inclusive)

                    // Iterate from the beginning of the roster up to the current entry (inclusive)
                    // to find all early starts within the 7-day rolling window.
                    for (let j = 0; j <= i; j++) {
                        const checkEntry = roster[j];
                        const checkBriefTimeMinutes = parseTime(checkEntry.briefTime);

                        const checkIsActualDuty = !(checkEntry.dutyType.toUpperCase().includes('RDO') ||
                                                     checkEntry.dutyType.toUpperCase().includes('GREY DAY') ||
                                                     checkEntry.dutyType.toUpperCase().includes('SBY') || // Exclude Standby
                                                     checkEntry.dutyType.toUpperCase().includes('LEAVE') ||
                                                     isNaN(checkBriefTimeMinutes)
                                                    );

                        // Check if the entry is within the 7-day window AND is an early actual duty start
                        if (checkEntry.date.getTime() >= windowStartTime && checkIsActualDuty && checkBriefTimeMinutes < SIX_AM_IN_MINUTES) {
                            earlyStartsInWindow++;
                        }
                    }

                    if (earlyStartsInWindow > earlyStartsThreshold) {
                        // To provide more specific feedback, let's list the dates of the early starts
                        let violatingDates = [];
                        for (let j = 0; j <= i; j++) {
                            const checkEntry = roster[j];
                            const checkBriefTimeMinutes = parseTime(checkEntry.briefTime);
                             const checkIsActualDuty = !(checkEntry.dutyType.toUpperCase().includes('RDO') ||
                                                     checkEntry.dutyType.toUpperCase().includes('GREY DAY') ||
                                                     checkEntry.dutyType.toUpperCase().includes('SBY') ||
                                                     checkEntry.dutyType.toUpperCase().includes('LEAVE') ||
                                                     isNaN(checkBriefTimeMinutes)
                                                    );
                            if (checkEntry.date.getTime() >= windowStartTime && checkIsActualDuty && checkBriefTimeMinutes < SIX_AM_IN_MINUTES) {
                                violatingDates.push(`${checkEntry.dateString} (${checkEntry.briefTime})`);
                            }
                        }

                        addBreach(`Early Starts Breach: On ${currentEntry.dateString}, there are ${earlyStartsInWindow} duties starting before 06:00 within the 7-day period ending on this date. Maximum allowed is ${earlyStartsThreshold}. Violating duties: ${violatingDates.join(', ')}.`);
                    }
                }
            }


            // Display overall result
            if (breachesFound.length === 0) {
                const li = document.createElement('li');
                li.textContent = "No roster breaches found based on the implemented checks.";
                li.classList.add('no-breach');
                breachList.appendChild(li);
            }

            document.getElementById('breachResults').style.display = 'block'; // Show results div
        }


        function generatePrintout() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) return alert("Paste your roster first.");
            lines = cleanHeaderLines(lines);

            const tbody = document.getElementById('printTableBody');
            const table = document.getElementById('printTable');
            tbody.innerHTML = '';

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [];
            let totals = [0, 0, 0, 0];

            function parseMinutes(time) {
                const [h, m] = time.split(':').map(Number);
                return h * 60 + m;
            }

            function formatMinutes(mins) {
                const h = Math.floor(mins / 60);
                const m = mins % 60;
                return `${h}:${m.toString().padStart(2, '0')}`;
            }

            function flushRow() {
                if (!buffer.length) return;

                const row = Array(10).fill('');
                const start = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < start.length && i < 5; i++) row[i] = start[i];

                const [dd, mon, yyyy] = row[0].split(/[\/\s]/);
                // Similar year handling as in parseRosterData
                let currentYear = new Date().getFullYear();
                if (yyyy && !isNaN(Number(yyyy))) {
                    currentYear = Number(yyyy);
                }
                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const d = new Date(currentYear, months[mon], Number(dd));
                const dayOfWeek = d.toLocaleDateString('en-AU', { weekday: 'short' });
                const fullDay = d.toLocaleDateString('en-AU', { weekday: 'long' });
                row[0] = `${dayOfWeek} ${row[0]}`;
                const isWeekend = (fullDay === 'Saturday' || fullDay === 'Sunday');

                const summaryIndex = buffer.findIndex(l => timeSummaryRegex.test(l));
                let summary = [];
                if (summaryIndex !== -1) {
                    summary = buffer[summaryIndex].split(/\t| {2,}/);
                    buffer.splice(summaryIndex, 1);
                }

                row[5] = buffer.slice(1).join('\n'); // Details from remaining buffer lines
                for (let i = 0; i < summary.length; i++) row[6 + i] = summary[i];

                for (let i = 6; i <= 9; i++) {
                    if (row[i].match(/^\d{1,2}:\d{2}$/)) {
                        totals[i - 6] += parseMinutes(row[i]);
                    }
                }

                const tr = document.createElement('tr');
                if (isWeekend) tr.classList.add('weekend-row');
                row.forEach(val => {
                    const td = document.createElement('td');
                    td.textContent = val;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line)) flushRow();
                buffer.push(line);
            });
            flushRow();

            const summaryRow = document.createElement('tr');
            for (let i = 0; i < 10; i++) {
                const td = document.createElement('td');
                if (i === 0) td.textContent = 'TOTAL';
                if (i >= 6) td.textContent = formatMinutes(totals[i - 6]);
                summaryRow.appendChild(td);
            }
            summaryRow.style.fontWeight = 'bold';
            summaryRow.style.borderTop = '2px solid #000';
            tbody.appendChild(summaryRow);

            table.style.display = 'table';
            window.print();
        }
    </script>
</body>
</html>
