<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Roster to ICS Exporter</title>
    <style>
        /* Your existing CSS */
        * { box-sizing: border-box; }

        body {
            font-family: sans-serif;
            margin: 1em;
            background: #f8f8f8;
            overflow-x: hidden;
            position: relative;
        }

        .logo {
            text-align: center;
            margin-bottom: 10px;
        }

        .logo img {
            max-width: 180px;
            height: auto;
            margin-top: 10px;
            margin-bottom: 10px;
            box-shadow: 0 0 8px rgba(0,0,0,0.05);
        }

        .top-controls {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        .dark-toggle-btn {
            padding: 0.6em 1em;
            font-size: 1em;
            font-weight: bold;
            border: 1px solid #ccc;
            background: #eee;
            cursor: pointer;
            border-radius: 6px;
        }

        hr.divider {
            max-width: 200px;
            margin: 0 auto 20px auto;
            border: 0;
            border-top: 1px solid #ccc;
        }

        .container {
            max-width: 1000px;
            margin: auto;
            background: #fff;
            padding: 1em;
            box-shadow: 0 0 10px #ccc;
            border-radius: 8px;
        }

        textarea {
            width: 100%;
            height: 350px;
            max-width: 100%;
            display: block;
            font-family: monospace;
            padding: 1em;
            border: 1px solid #ccc;
            resize: vertical;
            font-size: 14px;
            line-height: 1.5;
        }

        button {
            margin: 0.5em 0.5em 0 0;
            padding: 0.6em 1.2em;
            font-size: 1em;
            cursor: pointer;
            border-radius: 6px; /* Added for consistency */
            border: 1px solid #ccc; /* Added for consistency */
            background: #eee; /* Added for consistency */
        }

        button:hover {
            background-color: #e0e0e0; /* Added hover effect */
        }

        table#printTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
            display: none;
        }

        table#printTable, table#printTable th, table#printTable td {
            border: 1px solid #333;
        }

        table#printTable th, table#printTable td {
            padding: 2px 4px;
            font-size: 9pt;
            text-align: left;
            vertical-align: top;
            white-space: pre-wrap;
        }

        .weekend-row {
            background-color: #e0e0e0 !important;
        }

        /* Styles for breach results display */
        #breachResults {
            margin-top: 1em;
            padding: 1em;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 5px;
            max-height: 200px; /* Limit height for scroll if many breaches */
            overflow-y: auto; /* Enable scrolling if content exceeds max-height */
            display: none; /* Hidden by default, shown when results are available */
        }

        #breachResults h3 {
            margin-top: 0;
            color: #333;
        }

        #breachResults ul {
            list-style-type: none;
            padding: 0;
        }

        #breachResults li {
            margin-bottom: 0.5em;
            font-weight: bold;
            color: #d9534f; /* Red for breaches */
        }

        #breachResults li.no-breach {
            color: #5cb85c; /* Green for no breaches */
        }

        @media print {
            .logo, .top-controls, textarea, button, hr.divider, #breachResults {
                display: none !important;
            }

            body {
                background: white;
                margin: 0;
            }

            .container {
                box-shadow: none;
                padding: 0;
                max-width: 100%;
            }

            table#printTable {
                display: table;
            }

            .weekend-row {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
                background-color: #e0e0e0 !important;
            }
        }

        /* Dark mode styles */
        body.dark-mode {
            background: #121212;
            color: #f0f0f0;
        }

        body.dark-mode .container {
            background: #1e1e1e;
            box-shadow: 0 0 10px #000;
        }

        body.dark-mode textarea {
            background: #2a2a2a;
            color: #f0f0f0;
            border: 1px solid #555;
        }

        body.dark-mode button,
        body.dark-mode .dark-toggle-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
        }

        body.dark-mode button:hover {
            background-color: #555;
        }

        body.dark-mode table#printTable {
            background: #1e1e1e;
            color: #f0f0f0;
        }

        body.dark-mode table#printTable th,
        body.dark-mode table#printTable td {
            border-color: #555;
        }

        body.dark-mode .weekend-row {
            background-color: #2f2f2f !important;
        }

        body.dark-mode #breachResults {
            background-color: #2a2a2a;
            border-color: #555;
        }

        body.dark-mode #breachResults h3 {
            color: #f0f0f0;
        }

        body.dark-mode #breachResults li {
            color: #ff9999; /* Lighter red for dark mode breaches */
        }
    </style>
</head>
<body>
    <div class="logo">
        <img src="alliance-logo.png" alt="Alliance Airlines Logo">
    </div>
    <hr class="divider">

    <div class="top-controls">
        <button class="dark-toggle-btn" onclick="toggleDarkMode()" id="darkModeBtn">Switch to Dark Mode</button>
    </div>

    <div class="container">
        <textarea id="rosterInput" placeholder="Paste your roster here..."></textarea><br/>
        <button onclick="generatePrintout()">Print This Page</button>
        <button onclick="generateICS()">Download ICS File</button>
        <button onclick="checkForBreaches()">Check for Roster Breaches</button>
        <div id="breachResults">
            <h3>Roster Breach Check Results:</h3>
            <ul id="breachList">
            </ul>
        </div>

        <table id="printTable">
            <thead>
                <tr>
                    <th>Duty Date</th>
                    <th>Duty</th>
                    <th>Brief</th>
                    <th>Debrief</th>
                    <th>Layover</th>
                    <th>Details</th>
                    <th>Duty</th>
                    <th>Flight</th>
                    <th>Pax</th>
                    <th>Credit</th>
                </tr>
            </thead>
            <tbody id="printTableBody"></tbody>
        </table>
    </div>

    <script>
        function toggleDarkMode() {
            const body = document.body;
            const btn = document.getElementById('darkModeBtn');
            const isDark = body.classList.toggle('dark-mode');
            btn.textContent = isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode';
            localStorage.setItem('darkMode', isDark ? 'dark' : 'light');
        }

        window.onload = function () {
            const saved = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const shouldDark = saved === 'dark' || (!saved && prefersDark);
            if (shouldDark) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeBtn').textContent = 'Switch to Light Mode';
            }
        };

        function pad(n) {
            return n.toString().padStart(2, '0');
        }

        function cleanHeaderLines(lines) {
            const knownHeaders = [
                'Duty Date\tDuty\tBrief Time\tDebrief Time\tLayover\tDetails\tDuty hours\tFlight hours\tPax Hours\tCredit Hours',
                'Duty\tDate\tDuty\tBrief\tTime\tDebrief\tTime\tLayover'
            ];
            return lines.filter(line =>
                !knownHeaders.some(h =>
                    line.replace(/\s+/g, '').includes(h.replace(/\s+/g, ''))
                )
            );
        }

        function generateICS() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) return alert("Paste your roster first.");
            lines = cleanHeaderLines(lines);

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [], events = [];

            function flushRow() {
                if (!buffer.length) return;
                const row = Array(10).fill('');
                const start = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < start.length && i < 5; i++) row[i] = start[i];

                const [dd, mon, yyyy] = row[0].split(/[\/\s]/);
                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const d = new Date(yyyy, months[mon], dd);

                const brief = row[2] || '00:00';
                const debrief = row[3] || '00:00';
                const duty = row[1];
                const details = row[5].replace(/\n/g, ' | ');
                const formatTime = (t) => t.replace(/:/g, '') + '00';

                const dtStart = yyyy + pad(d.getMonth() + 1) + pad(d.getDate()) + 'T' + formatTime(brief);
                const dtEnd = yyyy + pad(d.getMonth() + 1) + pad(d.getDate()) + 'T' + formatTime(debrief);

                events.push(`BEGIN:VEVENT\nSUMMARY:${duty} ${brief} ${details}\nDTSTART;TZID=Australia/Brisbane:${dtStart}\nDTEND;TZID=Australia/Brisbane:${dtEnd}\nDESCRIPTION:Brief: ${brief} | ${details}\nUID:roster-${dtStart}@roster.local\nDTSTAMP:${dtStart}Z\nEND:VEVENT`);
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line)) flushRow();
                buffer.push(line);
            });
            flushRow();

            const ics = `BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\nMETHOD:PUBLISH\nX-WR-TIMEZONE:Australia/Brisbane\nBEGIN:VTIMEZONE\nTZID:Australia/Brisbane\nBEGIN:STANDARD\nDTSTART:19700101T000000\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1000\nTZNAME:AEST\nEND:STANDARD\nEND:VTIMEZONE\n${events.join('\n')}\nEND:VCALENDAR`;

            const blob = new Blob([ics.replace(/\n/g, "\r\n")], { type: 'text/calendar' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'roster_export.ics';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // --- NEW BREACH CHECKING FUNCTIONALITY ---

        function parseTime(timeStr) {
            if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
                return NaN;
            }
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function formatMinutesToHHMM(totalMinutes) {
            if (isNaN(totalMinutes)) return 'Invalid Time';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function parseRosterData() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) {
                alert("Please paste your roster first.");
                return null;
            }
            lines = cleanHeaderLines(lines);

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [];
            const rosterEntries = [];

            function processBuffer() {
                if (!buffer.length) return;

                const rowData = Array(10).fill('');
                const initialSplit = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < initialSplit.length && i < 5; i++) rowData[i] = initialSplit[i];

                const [dayStr, monStr, yearStr] = rowData[0].split(/[\/\s]/);
                let currentYear = new Date().getFullYear();
                if (yearStr && !isNaN(Number(yearStr))) {
                     currentYear = Number(yearStr);
                }

                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const date = new Date(currentYear, months[monStr], Number(dayStr));

                let summaryParts = [];
                const summaryIndex = buffer.findIndex(l => timeSummaryRegex.test(l));
                if (summaryIndex !== -1) {
                    summaryParts = buffer[summaryIndex].split(/\t| {2,}/);
                    buffer.splice(summaryIndex, 1);
                }

                rowData[5] = buffer.slice(1).join('\n');
                for (let i = 0; i < summaryParts.length; i++) rowData[6 + i] = summaryParts[i];

                rosterEntries.push({
                    date: date,
                    dateString: rowData[0],
                    dutyType: rowData[1] ? rowData[1].trim() : '',
                    briefTime: rowData[2] ? rowData[2].trim() : '',
                    debriefTime: rowData[3] ? rowData[3].trim() : '',
                    layover: rowData[4] ? rowData[4].trim() : '',
                    details: rowData[5] ? rowData[5].trim() : '',
                    dutyHours: rowData[6] ? rowData[6].trim() : '',
                    flightHours: rowData[7] ? rowData[7].trim() : '',
                    paxHours: rowData[8] ? rowData[8].trim() : '',
                    creditHours: rowData[9] ? rowData[9].trim() : ''
                });
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line) && buffer.length > 0) {
                    processBuffer();
                }
                buffer.push(line);
            });
            processBuffer();

            return rosterEntries;
        }

        function checkForBreaches() {
            const roster = parseRosterData();
            if (!roster) {
                document.getElementById('breachResults').style.display = 'none';
                return;
            }

            const breachList = document.getElementById('breachList');
            breachList.innerHTML = '';
            const breachesFound = [];

            function addBreach(message) {
                breachesFound.push(message);
                const li = document.createElement('li');
                li.textContent = message;
                breachList.appendChild(li);
            }

            // --- Early Starts Breach Check (Consecutive Days with Breach) ---
            const earlyStartsThreshold = 3; // Max allowed is 3, so > 3 is a breach
            const SIX_AM_IN_MINUTES = parseTime('06:00');

            let consecutiveEarlyStarts = 0;
            let earlyStartBreachStartDate = null;

            for (let i = 0; i < roster.length; i++) {
                const currentEntry = roster[i];
                const currentBriefTimeMinutes = parseTime(currentEntry.briefTime);

                const isActualDutyStartCandidate = !(
                    currentEntry.dutyType.toUpperCase().includes('RDO') ||
                    currentEntry.dutyType.toUpperCase().includes('GREY DAY') ||
                    currentEntry.dutyType.toUpperCase().includes('SBY') ||
                    currentEntry.dutyType.toUpperCase().includes('LEAVE') ||
                    isNaN(currentBriefTimeMinutes)
                );

                if (isActualDutyStartCandidate && currentBriefTimeMinutes < SIX_AM_IN_MINUTES) {
                    consecutiveEarlyStarts++;
                    if (earlyStartBreachStartDate === null) {
                        earlyStartBreachStartDate = currentEntry.dateString;
                    }
                } else {
                    if (consecutiveEarlyStarts > earlyStartsThreshold) {
                        addBreach(`Early Starts Breach: Started on ${earlyStartBreachStartDate}, with ${consecutiveEarlyStarts} consecutive duties starting before 06:00 (more than ${earlyStartsThreshold} allowed).`);
                    }
                    consecutiveEarlyStarts = 0;
                    earlyStartBreachStartDate = null;
                }
            }
            if (consecutiveEarlyStarts > earlyStartsThreshold) {
                addBreach(`Early Starts Breach: Started on ${earlyStartBreachStartDate}, with ${consecutiveEarlyStarts} consecutive duties starting before 06:00 (more than ${earlyStartsThreshold} allowed).`);
            }

            // --- Minimum RDOs Check ---
            const RDO_MINIMUM = 8; // Minimum RDOs required per roster period
            const ROSTER_PERIOD_DAYS = 28; // A Roster Period is 28 days

            if (roster.length > 0) {
                const firstDate = roster[0].date;
                const lastDate = roster[roster.length - 1].date;

                const rosterDurationMs = lastDate.getTime() - firstDate.getTime();
                const rosterDurationDays = Math.round(rosterDurationMs / (1000 * 60 * 60 * 24)) + 1; // +1 to include both start and end day

                if (rosterDurationDays >= (ROSTER_PERIOD_DAYS - 1) && rosterDurationDays <= (ROSTER_PERIOD_DAYS + 1)) { // Allowing for +/- 1 day variation
                    let rdoCount = 0;
                    for (const entry of roster) {
                        if (entry.dutyType.toUpperCase().includes('RDO')) {
                            rdoCount++;
                        }
                    }

                    if (rdoCount < RDO_MINIMUM) {
                        addBreach(`RDO Breach: Only ${rdoCount} RDOs rostered in the ${rosterDurationDays}-day period from ${firstDate.toLocaleDateString('en-AU')} to ${lastDate.toLocaleDateString('en-AU')}. A minimum of ${RDO_MINIMUM} RDOs are required.`);
                    }
                }
            }

            // --- One Weekend Off Check ---
            let hasWeekendOff = false;
            if (roster.length > 0) {
                for (let i = 0; i < roster.length - 1; i++) {
                    const currentEntry = roster[i];
                    const nextEntry = roster[i + 1];

                    const currentDayOfWeek = currentEntry.date.getDay(); // 0 for Sunday, 6 for Saturday
                    const nextDayOfWeek = nextEntry.date.getDay();

                    if (currentDayOfWeek === 6 && nextDayOfWeek === 0) { // Saturday (6), Sunday (0)
                        if (currentEntry.dutyType.toUpperCase().includes('RDO') &&
                            nextEntry.dutyType.toUpperCase().includes('RDO')) {
                            hasWeekendOff = true;
                            break;
                        }
                    }
                }

                const firstDate = roster[0].date;
                const lastDate = roster[roster.length - 1].date;
                const rosterDurationMs = lastDate.getTime() - firstDate.getTime();
                const rosterDurationDays = Math.round(rosterDurationMs / (1000 * 60 * 60 * 24)) + 1;

                if (!hasWeekendOff && rosterDurationDays >= (ROSTER_PERIOD_DAYS - 1) && rosterDurationDays <= (ROSTER_PERIOD_DAYS + 1)) {
                    addBreach(`Weekend Off Breach: No full weekend (Saturday and Sunday as RDOs) found in the roster period.`);
                }
            }

            // --- Consecutive Duty Tours Check (6 days on, needs 2 days off before next 6 days on) ---
            const DUTY_TOUR_LENGTH = 6;
            const REQUIRED_DAYS_OFF_BETWEEN_TOURS = 2;

            let consecutiveDutyDays = 0;
            let dutyTourStartDates = []; // Stores start dates of 6-day duty tours

            for (let i = 0; i < roster.length; i++) {
                const entry = roster[i];
                const isDutyDay = !(
                    entry.dutyType.toUpperCase().includes('RDO') ||
                    entry.dutyType.toUpperCase().includes('GREY DAY') ||
                    entry.dutyType.toUpperCase().includes('SBY') ||
                    entry.dutyType.toUpperCase().includes('LEAVE')
                );

                if (isDutyDay) {
                    consecutiveDutyDays++;
                } else {
                    // If the streak of duty days is broken
                    if (consecutiveDutyDays >= DUTY_TOUR_LENGTH) {
                        // A potential 6-day (or more) duty tour has just ended
                        const tourStartDate = roster[i - consecutiveDutyDays].dateString;
                        const tourEndDate = roster[i - 1].dateString;
                        dutyTourStartDates.push({ start: tourStartDate, end: tourEndDate, startIndex: i - consecutiveDutyDays });
                    }
                    consecutiveDutyDays = 0; // Reset consecutive duty days
                }

                // If the loop ends and there's an ongoing streak of duty days
                if (i === roster.length - 1 && consecutiveDutyDays >= DUTY_TOUR_LENGTH) {
                    const tourStartDate = roster[i - consecutiveDutyDays + 1].dateString;
                    const tourEndDate = roster[i].dateString;
                    dutyTourStartDates.push({ start: tourStartDate, end: tourEndDate, startIndex: i - consecutiveDutyDays + 1 });
                }
            }

            // Now, check the identified duty tours for breaches
            for (let i = 0; i < dutyTourStartDates.length - 1; i++) {
                const firstTour = dutyTourStartDates[i];
                const secondTour = dutyTourStartDates[i + 1];

                const daysBetween = [];
                // Collect days between the end of the first tour and the start of the second tour
                for (let j = firstTour.startIndex + DUTY_TOUR_LENGTH; j < secondTour.startIndex; j++) {
                    if (j < roster.length) { // Ensure index is within bounds
                        daysBetween.push(roster[j]);
                    }
                }

                let daysOffBetweenTours = 0;
                for (const day of daysBetween) {
                    if (day.dutyType.toUpperCase().includes('RDO') || day.dutyType.toUpperCase().includes('GREY DAY')) {
                        daysOffBetweenTours++;
                    } else {
                        // If any non-RDO/Grey day is found, this means the consecutive days off requirement is broken.
                        // However, the rule states "minimum of two (2) consecutive days off",
                        // so we need to ensure the days *are* consecutive.
                        // For simplicity, we'll count total RDO/Grey days here and then check consecutiveness later if needed.
                        // For now, let's assume "minimum of two (2) consecutive days off" simply means
                        // that there are at least two RDO/Grey days and no duties in between *within that buffer*.
                    }
                }

                // To strictly check "consecutive days off", we need to check the actual sequence.
                // Let's modify the check here to look at the buffer days.
                let currentConsecutiveDaysOff = 0;
                let maxConsecutiveDaysOffFound = 0;
                for (const day of daysBetween) {
                    if (day.dutyType.toUpperCase().includes('RDO') || day.dutyType.toUpperCase().includes('GREY DAY')) {
                        currentConsecutiveDaysOff++;
                    } else {
                        maxConsecutiveDaysOffFound = Math.max(maxConsecutiveDaysOffFound, currentConsecutiveDaysOff);
                        currentConsecutiveDaysOff = 0;
                    }
                }
                maxConsecutiveDaysOffFound = Math.max(maxConsecutiveDaysOffFound, currentConsecutiveDaysOff); // Check after loop

                if (maxConsecutiveDaysOffFound < REQUIRED_DAYS_OFF_BETWEEN_TOURS) {
                    addBreach(`Consecutive Duty Tours Breach: Pilot worked 6+ days (from ${firstTour.start} to ${firstTour.end}) followed by another 6+ days (starting ${secondTour.start}) without a minimum of ${REQUIRED_DAYS_OFF_BETWEEN_TOURS} consecutive days off in between. Only found ${maxConsecutiveDaysOffFound} consecutive days off.`);
                }
            }


            // Display overall result
            if (breachesFound.length === 0) {
                const li = document.createElement('li');
                li.textContent = "No roster breaches found based on the implemented checks.";
                li.classList.add('no-breach');
                breachList.appendChild(li);
            }

            document.getElementById('breachResults').style.display = 'block';
        }


        function generatePrintout() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) return alert("Paste your roster first.");
            lines = cleanHeaderLines(lines);

            const tbody = document.getElementById('printTableBody');
            const table = document.getElementById('printTable');
            tbody.innerHTML = '';

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [];
            let totals = [0, 0, 0, 0];

            function parseMinutes(time) {
                const [h, m] = time.split(':').map(Number);
                return h * 60 + m;
            }

            function formatMinutes(mins) {
                const h = Math.floor(mins / 60);
                const m = mins % 60;
                return `${h}:${m.toString().padStart(2, '0')}`;
            }

            function flushRow() {
                if (!buffer.length) return;

                const row = Array(10).fill('');
                const start = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < start.length && i < 5; i++) row[i] = start[i];

                const [dd, mon, yyyy] = row[0].split(/[\/\s]/);
                let currentYear = new Date().getFullYear();
                if (yyyy && !isNaN(Number(yyyy))) {
                    currentYear = Number(yyyy);
                }
                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const d = new Date(currentYear, months[mon], Number(dd));
                const dayOfWeek = d.toLocaleDateString('en-AU', { weekday: 'short' });
                const fullDay = d.toLocaleDateString('en-AU', { weekday: 'long' });
                row[0] = `${dayOfWeek} ${row[0]}`;
                const isWeekend = (fullDay === 'Saturday' || fullDay === 'Sunday');

                const summaryIndex = buffer.findIndex(l => timeSummaryRegex.test(l));
                let summary = [];
                if (summaryIndex !== -1) {
                    summary = buffer[summaryIndex].split(/\t| {2,}/);
                    buffer.splice(summaryIndex, 1);
                }

                row[5] = buffer.slice(1).join('\n');
                for (let i = 0; i < summary.length; i++) row[6 + i] = summary[i];

                for (let i = 6; i <= 9; i++) {
                    if (row[i].match(/^\d{1,2}:\d{2}$/)) {
                        totals[i - 6] += parseMinutes(row[i]);
                    }
                }

                const tr = document.createElement('tr');
                if (isWeekend) tr.classList.add('weekend-row');
                row.forEach(val => {
                    const td = document.createElement('td');
                    td.textContent = val;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line)) flushRow();
                buffer.push(line);
            });
            flushRow();

            const summaryRow = document.createElement('tr');
            for (let i = 0; i < 10; i++) {
                const td = document.createElement('td');
                if (i === 0) td.textContent = 'TOTAL';
                if (i >= 6) td.textContent = formatMinutes(totals[i - 6]);
                summaryRow.appendChild(td);
            }
            summaryRow.style.fontWeight = 'bold';
            summaryRow.style.borderTop = '2px solid #000';
            tbody.appendChild(summaryRow);

            table.style.display = 'table';
            window.print();
        }
    </script>
</body>
</html>
