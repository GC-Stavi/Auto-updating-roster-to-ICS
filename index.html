<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Roster to ICS Exporter</title>
    <style>
        /* Your existing CSS */
        * { box-sizing: border-box; }

        body {
            font-family: sans-serif;
            margin: 1em;
            background: #f8f8f8;
            overflow-x: hidden;
            position: relative;
        }

        .logo {
            text-align: center;
            margin-bottom: 10px;
        }

        .logo img {
            max-width: 180px;
            height: auto;
            margin-top: 10px;
            margin-bottom: 10px;
            box-shadow: 0 0 8px rgba(0,0,0,0.05);
        }

        .top-controls {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        .dark-toggle-btn {
            padding: 0.6em 1em;
            font-size: 1em;
            font-weight: bold;
            border: 1px solid #ccc;
            background: #eee;
            cursor: pointer;
            border-radius: 6px;
        }

        hr.divider {
            max-width: 200px;
            margin: 0 auto 20px auto;
            border: 0;
            border-top: 1px solid #ccc;
        }

        .container {
            max-width: 1000px;
            margin: auto;
            background: #fff;
            padding: 1em;
            box-shadow: 0 0 10px #ccc;
            border-radius: 8px;
        }

        textarea {
            width: 100%;
            height: 350px;
            max-width: 100%;
            display: block;
            font-family: monospace;
            padding: 1em;
            border: 1px solid #ccc;
            resize: vertical;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Adjust button margins to prevent excessive spacing with flexbox */
        button {
            margin: 0 0.5em 0 0; /* Top, Right, Bottom, Left */
            padding: 0.6em 1.2em;
            font-size: 1em;
            cursor: pointer;
            border-radius: 6px;
            border: 1px solid #ccc;
            background: #eee;
        }

        button:hover {
            background-color: #e0e0e0;
        }

        /* New style for the "Check for Roster Breaches" button */
        .check-breaches-button {
            background-color: #ffc107; /* A subtle yellow */
            border-color: #ffc107;
            color: #333; /* Darker text for contrast */
        }

        .check-breaches-button:hover {
            background-color: #e0a800; /* Darker yellow on hover */
            border-color: #e0a800;
        }

        table#printTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1em;
            display: none;
        }

        table#printTable, table#printTable th, table#printTable td {
            border: 1px solid #333;
        }

        table#printTable th, table#printTable td {
            padding: 2px 4px;
            font-size: 9pt;
            text-align: left;
            vertical-align: top;
            white-space: pre-wrap;
        }

        .weekend-row {
            background-color: #e0e0e0 !important;
        }

        /* Styles for breach results display */
        #breachResults {
            margin-top: 1em;
            padding: 1em;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        #breachResults h3 {
            margin-top: 0;
            color: #333;
        }

        #breachResults ul {
            list-style-type: none;
            padding: 0;
        }

        #breachResults li {
            margin-bottom: 0.5em;
            font-weight: bold;
            color: #d9534f;
        }

        #breachResults li.info {
            color: #337ab7;
            font-weight: normal;
        }

        #breachResults li.no-breach {
            color: #5cb85c;
        }

        /* Button group for alignment */
        .main-buttons-row {
            display: flex;
            justify-content: space-between; /* Pushes items to ends */
            align-items: center;
            flex-wrap: wrap; /* Allows wrapping on smaller screens */
            margin-top: 0.5em;
            margin-bottom: 0.5em; /* Add some space below the button row */
        }

        .left-buttons, .right-buttons {
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Allow buttons to wrap within their group */
        }

        .info-button {
            padding: 0.6em 1em;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
            border: 1px solid #ccc;
            background: #eee;
            /* Adjust margin for spacing within the right group */
            margin-left: 0.5em; /* Space between breach button and info button */
            margin-right: 0; /* Reset right margin as it's the last element */
        }

        .info-button:hover {
            background-color: #e0e0e0;
        }

        /* Modal/Popover styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-content h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2em;
        }

        .modal-content ul {
            list-style-type: disc;
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .modal-content li {
            margin-bottom: 5px;
            font-weight: normal;
            color: #555;
        }

        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
        }

        .modal-close-button:hover {
            color: #333;
        }

        /* Dark mode styles */
        body.dark-mode {
            background: #121212;
            color: #f0f0f0;
        }

        body.dark-mode .container {
            background: #1e1e1e;
            box-shadow: 0 0 10px #000;
        }

        body.dark-mode textarea {
            background: #2a2a2a;
            color: #f0f0f0;
            border: 1px solid #555;
        }

        body.dark-mode button,
        body.dark-mode .dark-toggle-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
        }

        body.dark-mode button:hover {
            background-color: #555;
        }

        body.dark-mode .check-breaches-button {
            background-color: #cc9900; /* Darker yellow for dark mode */
            border-color: #cc9900;
            color: #f0f0f0;
        }

        body.dark-mode .check-breaches-button:hover {
            background-color: #a67c00;
            border-color: #a67c00;
        }

        body.dark-mode table#printTable {
            background: #1e1e1e;
            color: #f0f0f0;
        }

        body.dark-mode table#printTable th,
        body.dark-mode table#printTable td {
            border-color: #555;
        }

        body.dark-mode .weekend-row {
            background-color: #2f2f2f !important;
        }

        body.dark-mode #breachResults {
            background-color: #2a2a2a;
            border-color: #555;
        }

        body.dark-mode #breachResults h3 {
            color: #f0f0f0;
        }

        body.dark-mode #breachResults li {
            color: #ff9999;
        }
        body.dark-mode #breachResults li.info {
            color: #99bbff;
        }
        body.dark-mode .info-button {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        body.dark-mode .info-button:hover {
            background-color: #555;
        }
        body.dark-mode .modal-content {
            background-color: #1e1e1e;
            color: #f0f0f0;
        }
        body.dark-mode .modal-content h4 {
            color: #f0f0f0;
        }
        body.dark-mode .modal-content li {
            color: #ccc;
        }
        body.dark-mode .modal-close-button {
            color: #888;
        }
        body.dark-mode .modal-close-button:hover {
            color: #f0f0f0;
        }

        @media print {
            .modal-overlay {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="logo">
        <img src="alliance-logo.png" alt="Alliance Airlines Logo">
    </div>
    <hr class="divider">

    <div class="top-controls">
        <button class="dark-toggle-btn" onclick="toggleDarkMode()" id="darkModeBtn">Switch to Dark Mode</button>
    </div>

    <div class="container">
        <textarea id="rosterInput" placeholder="Paste your roster here..."></textarea><br/>
        
        <div class="main-buttons-row">
            <div class="left-buttons">
                <button onclick="generatePrintout()">Print This Page</button>
                <button onclick="generateICS()">Download ICS File</button>
            </div>
            <div class="right-buttons">
                <button onclick="checkForBreaches()" class="check-breaches-button">Check for Roster Breaches</button>
                <button class="info-button" onclick="showBreachInfoModal()">?</button>
            </div>
        </div>

        <div id="breachResults">
            <h3>Roster Breach Check Results:</h3>
            <ul id="breachList">
            </ul>
        </div>

        <table id="printTable">
            <thead>
                <tr>
                    <th>Duty Date</th>
                    <th>Duty</th>
                    <th>Brief</th>
                    <th>Debrief</th>
                    <th>Layover</th>
                    <th>Details</th>
                    <th>Duty</th>
                    <th>Flight</th>
                    <th>Pax</th>
                    <th>Credit</th>
                </tr>
            </thead>
            <tbody id="printTableBody"></tbody>
        </table>
    </div>

    <div id="breachInfoModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <button class="modal-close-button" onclick="hideBreachInfoModal()">&times;</button>
            <h4>Roster Breach Check Information</h4>
            <p>These checks are based on the **Alliance Group (Qld Pilots) Enterprise Agreement 2024**.</p>
            <p>The tool currently checks for the following potential roster breaches:</p>
            <ul>
                <li>**Early Starts**: More than 3 consecutive starts before 06:00.</li>
                <li>**Minimum RDOs**: Fewer than 8 Rostered Days Off in a 28-day roster period.</li>
                <li>**Weekend Off**: No full Saturday and Sunday RDO block in a 28-day roster period.</li>
                <li>**Consecutive Duty Tours**: Two tours each consisting of 6 or more consecutive duty days without a minimum of 2 consecutive days off in between.</li>
                <li>**Rest Periods (Home Base)**: Less than 12 hours rest between duties when both duties are at Home Base.</li>
                <li>**Short Rest Periods (Info)**: Less than 12 hours rest between duties when one or both duties are away from Home Base. This is for information only as it might be permissible under specific FRMS rules (e.g., 10-hour rule when away).</li>
            </ul>
            <p>
                The tool **does NOT** currently check for:
                <ul>
                    <li>**Grey Day Directed Work**: (e.g., being directed to work on a Grey Day outside of assessment/remedial training, or if you have nominated to work).</li>
                    <li>Specific RDO and Grey Day buffer periods (e.g., 36-hour for 1 RDO, 60-hour for 2 RDOs, etc.).</li>
                    <li>Any Flight Duty Period (FDP) or Duty Time limitations based on CAO 48 or FRMS.</li>
                    <li>Maximum consecutive nights away from Home Base.</li>
                    <li>Any specific Rest Periods related to Standby.</li>
                    <li>Any other complex rostering rules or buffers.</li>
                </ul>
            </p>
            <p>
                *Note: This tool provides general guidance. Always refer to the official EA document and your company's rostering policy for definitive interpretation.*
            </p>
        </div>
    </div>

    <script>
        function toggleDarkMode() {
            const body = document.body;
            const btn = document.getElementById('darkModeBtn');
            const isDark = body.classList.toggle('dark-mode');
            btn.textContent = isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode';
            localStorage.setItem('darkMode', isDark ? 'dark' : 'light');
        }

        window.onload = function () {
            const saved = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const shouldDark = saved === 'dark' || (!saved && prefersDark);
            if (shouldDark) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeBtn').textContent = 'Switch to Light Mode';
            }
        };

        function pad(n) {
            return n.toString().padStart(2, '0');
        }

        function cleanHeaderLines(lines) {
            const knownHeaders = [
                'Duty Date\tDuty\tBrief Time\tDebrief Time\tLayover\tDetails\tDuty hours\tFlight hours\tPax Hours\tCredit Hours',
                'Duty\tDate\tDuty\tBrief\tTime\tDebrief\tTime\tLayover'
            ];
            return lines.filter(line =>
                !knownHeaders.some(h =>
                    line.replace(/\s+/g, '').includes(h.replace(/\s+/g, ''))
                )
            );
        }

        function generateICS() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) return alert("Paste your roster first.");
            lines = cleanHeaderLines(lines);

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [], events = [];

            function flushRow() {
                if (!buffer.length) return;
                const row = Array(10).fill('');
                const start = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < start.length && i < 5; i++) row[i] = start[i];

                const [dd, mon, yyyy] = row[0].split(/[\/\s]/);
                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const d = new Date(yyyy, months[mon], dd);

                const brief = row[2] || '00:00';
                const debrief = row[3] || '00:00';
                const duty = row[1];
                const details = row[5].replace(/\n/g, ' | ');
                const formatTime = (t) => t.replace(/:/g, '') + '00';

                const dtStart = yyyy + pad(d.getMonth() + 1) + pad(d.getDate()) + 'T' + formatTime(brief);
                const dtEnd = yyyy + pad(d.getMonth() + 1) + pad(d.getDate()) + 'T' + formatTime(debrief);

                events.push(`BEGIN:VEVENT\nSUMMARY:${duty} ${brief} ${details}\nDTSTART;TZID=Australia/Brisbane:${dtStart}\nDTEND;TZID=Australia/Brisbane:${dtEnd}\nDESCRIPTION:Brief: ${brief} | ${details}\nUID:roster-${dtStart}@roster.local\nDTSTAMP:${dtStart}Z\nEND:VEVENT`);
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line)) flushRow();
                buffer.push(line);
            });
            flushRow();

            const ics = `BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\nMETHOD:PUBLISH\nX-WR-TIMEZONE:Australia/Brisbane\nBEGIN:VTIMEZONE\nTZID:Australia/Brisbane\nBEGIN:STANDARD\nDTSTART:19700101T000000\nTZOFFSETFROM:+1000\nTZOFFSETTO:+1000\nTZNAME:AEST\nEND:STANDARD\nEND:VTIMEZONE\n${events.join('\n')}\nEND:VCALENDAR`;

            const blob = new Blob([ics.replace(/\n/g, "\r\n")], { type: 'text/calendar' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'roster_export.ics';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // --- NEW BREACH CHECKING FUNCTIONALITY ---

        function parseTime(timeStr) {
            if (!timeStr || typeof timeStr !== 'string' || !timeStr.includes(':')) {
                return NaN;
            }
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function formatMinutesToHHMM(totalMinutes) {
            if (isNaN(totalMinutes)) return 'Invalid Time';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function parseRosterData() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) {
                alert("Please paste your roster first.");
                return null;
            }
            lines = cleanHeaderLines(lines);

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [];
            const rosterEntries = [];

            function processBuffer() {
                if (!buffer.length) return;

                const rowData = Array(10).fill('');
                const initialSplit = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < initialSplit.length && i < 5; i++) rowData[i] = initialSplit[i];

                const [dayStr, monStr, yyyy] = rowData[0].split(/[\/\s]/);
                let currentYear = new Date().getFullYear();
                if (yyyy && !isNaN(Number(yyyy))) {
                     currentYear = Number(yyyy);
                }

                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const date = new Date(currentYear, months[monStr], Number(dayStr));

                let summaryParts = [];
                let detailsLines = [];
                let foundSummary = false;
                for (let k = 1; k < buffer.length; k++) {
                    if (timeSummaryRegex.test(buffer[k])) {
                        summaryParts = buffer[k].split(/\t| {2,}/);
                        foundSummary = true;
                        break;
                    } else {
                        detailsLines.push(buffer[k]);
                    }
                }
                rowData[5] = detailsLines.join('\n');

                if (!foundSummary && detailsLines.length > 0) {
                     const lastDetailLine = detailsLines[detailsLines.length - 1];
                     if (timeSummaryRegex.test(lastDetailLine)) {
                        summaryParts = lastDetailLine.split(/\t| {2,}/);
                        detailsLines.pop();
                        rowData[5] = detailsLines.join('\n');
                     }
                }
                
                for (let i = 0; i < summaryParts.length; i++) rowData[6 + i] = summaryParts[i];

                rosterEntries.push({
                    date: date,
                    dateString: rowData[0],
                    dutyType: rowData[1] ? rowData[1].trim() : '',
                    briefTime: rowData[2] ? rowData[2].trim() : '',
                    debriefTime: rowData[3] ? rowData[3].trim() : '',
                    layover: rowData[4] ? rowData[4].trim() : '',
                    details: rowData[5] ? rowData[5].trim() : '',
                    dutyHours: rowData[6] ? rowData[6].trim() : '',
                    flightHours: rowData[7] ? rowData[7].trim() : '',
                    paxHours: rowData[8] ? rowData[8].trim() : '',
                    creditHours: rowData[9] ? rowData[9].trim() : ''
                });
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line) && buffer.length > 0) {
                    processBuffer();
                }
                buffer.push(line);
            });
            processBuffer();

            return rosterEntries;
        }

        function checkForBreaches() {
            const roster = parseRosterData();
            if (!roster) {
                document.getElementById('breachResults').style.display = 'none';
                return;
            }

            const breachList = document.getElementById('breachList');
            breachList.innerHTML = '';
            const breachesFound = [];

            function addBreach(message, isInfo = false) {
                breachesFound.push(message);
                const li = document.createElement('li');
                li.textContent = message;
                if (isInfo) {
                    li.classList.add('info');
                }
                breachList.appendChild(li);
            }

            // --- Early Starts Breach Check (4+ consecutive before 06:00) ---
            const earlyStartsThreshold = 3;
            const SIX_AM_IN_MINUTES = parseTime('06:00');

            let consecutiveEarlyStarts = 0;
            let earlyStartBreachStartDate = null;

            for (let i = 0; i < roster.length; i++) {
                const currentEntry = roster[i];
                const currentBriefTimeMinutes = parseTime(currentEntry.briefTime);

                const isActualDutyStartCandidate = !(
                    currentEntry.dutyType.toUpperCase().includes('RDO') ||
                    currentEntry.dutyType.toUpperCase().includes('GREY DAY') ||
                    currentEntry.dutyType.toUpperCase().includes('SBY') ||
                    currentEntry.dutyType.toUpperCase().includes('LEAVE') ||
                    isNaN(currentBriefTimeMinutes)
                );

                if (isActualDutyStartCandidate && currentBriefTimeMinutes < SIX_AM_IN_MINUTES) {
                    consecutiveEarlyStarts++;
                    if (earlyStartBreachStartDate === null) {
                        earlyStartBreachStartDate = currentEntry.dateString;
                    }
                } else {
                    if (consecutiveEarlyStarts > earlyStartsThreshold) {
                        addBreach(`Early Starts Breach: Started on ${earlyStartBreachStartDate}, with ${consecutiveEarlyStarts} consecutive duties starting before 06:00 (more than ${earlyStartsThreshold} allowed).`);
                    }
                    consecutiveEarlyStarts = 0;
                    earlyStartBreachStartDate = null;
                }
            }
            if (consecutiveEarlyStarts > earlyStartsThreshold) {
                addBreach(`Early Starts Breach: Started on ${earlyStartBreachStartDate}, with ${consecutiveEarlyStarts} consecutive duties starting before 06:00 (more than ${earlyStartsThreshold} allowed).`);
            }

            // --- Minimum RDOs Check (fewer than 8 in 28 days) ---
            const RDO_MINIMUM = 8;
            const ROSTER_PERIOD_DAYS = 28;

            if (roster.length > 0) {
                const firstDate = roster[0].date;
                const lastDate = roster[roster.length - 1].date;

                const rosterDurationMs = lastDate.getTime() - firstDate.getTime();
                const rosterDurationDays = Math.round(rosterDurationMs / (1000 * 60 * 60 * 24)) + 1;

                if (rosterDurationDays >= (ROSTER_PERIOD_DAYS - 1) && rosterDurationDays <= (ROSTER_PERIOD_DAYS + 1)) {
                    let rdoCount = 0;
                    for (const entry of roster) {
                        if (entry.dutyType.toUpperCase().includes('RDO')) {
                            rdoCount++;
                        }
                    }

                    if (rdoCount < RDO_MINIMUM) {
                        addBreach(`RDO Breach: Only ${rdoCount} RDOs rostered in the ${rosterDurationDays}-day period from ${firstDate.toLocaleDateString('en-AU')} to ${lastDate.toLocaleDateString('en-AU')}. A minimum of ${RDO_MINIMUM} RDOs are required.`);
                    }
                }
            }

            // --- One Weekend Off Check (no Sat/Sun RDO block) ---
            let hasWeekendOff = false;
            if (roster.length > 0) {
                for (let i = 0; i < roster.length - 1; i++) {
                    const currentEntry = roster[i];
                    const nextEntry = roster[i + 1];

                    const currentDayOfWeek = currentEntry.date.getDay();
                    const nextDayOfWeek = nextEntry.date.getDay();

                    if (currentDayOfWeek === 6 && nextDayOfWeek === 0) { // Saturday (6), Sunday (0)
                        if (currentEntry.dutyType.toUpperCase().includes('RDO') &&
                            nextEntry.dutyType.toUpperCase().includes('RDO')) {
                            hasWeekendOff = true;
                            break;
                        }
                    }
                }

                const firstDate = roster[0].date;
                const lastDate = roster[roster.length - 1].date;
                const rosterDurationMs = lastDate.getTime() - firstDate.getTime();
                const rosterDurationDays = Math.round(rosterDurationMs / (1000 * 60 * 60 * 24)) + 1;

                if (!hasWeekendOff && rosterDurationDays >= (ROSTER_PERIOD_DAYS - 1) && rosterDurationDays <= (ROSTER_PERIOD_DAYS + 1)) {
                    addBreach(`Weekend Off Breach: No full weekend (Saturday and Sunday as RDOs) found in the roster period.`);
                }
            }

            // --- Consecutive Duty Tours Check (two 6+ day tours without 2+ consecutive days off in between) ---
            const DUTY_TOUR_LENGTH = 6;
            const REQUIRED_DAYS_OFF_BETWEEN_TOURS = 2;

            let consecutiveDutyDays = 0;
            let dutyTourDetails = [];

            for (let i = 0; i < roster.length; i++) {
                const entry = roster[i];
                const isDutyDay = !(
                    entry.dutyType.toUpperCase().includes('RDO') ||
                    entry.dutyType.toUpperCase().includes('GREY DAY') ||
                    entry.dutyType.toUpperCase().includes('SBY') ||
                    entry.dutyType.toUpperCase().includes('LEAVE')
                );

                if (isDutyDay) {
                    consecutiveDutyDays++;
                } else {
                    if (consecutiveDutyDays >= DUTY_TOUR_LENGTH) {
                        const tourStartDate = roster[i - consecutiveDutyDays].dateString;
                        const tourEndDate = roster[i - 1].dateString;
                        dutyTourDetails.push({ start: tourStartDate, end: tourEndDate, startIndex: i - consecutiveDutyDays });
                    }
                    consecutiveDutyDays = 0;
                }

                if (i === roster.length - 1 && consecutiveDutyDays >= DUTY_TOUR_LENGTH) {
                    const tourStartDate = roster[i - consecutiveDutyDays + 1].dateString;
                    const tourEndDate = roster[i].dateString;
                    dutyTourDetails.push({ start: tourStartDate, end: tourEndDate, startIndex: i - consecutiveDutyDays + 1 });
                }
            }

            for (let i = 0; i < dutyTourDetails.length - 1; i++) {
                const firstTour = dutyTourDetails[i];
                const secondTour = dutyTourDetails[i + 1];

                let maxConsecutiveDaysOffFound = 0;
                let currentConsecutiveDaysOffStreak = 0;

                for (let j = firstTour.startIndex + DUTY_TOUR_LENGTH; j < secondTour.startIndex; j++) {
                    if (j < roster.length) {
                        const dayBetween = roster[j];
                        if (dayBetween.dutyType.toUpperCase().includes('RDO') || dayBetween.dutyType.toUpperCase().includes('GREY DAY')) {
                            currentConsecutiveDaysOffStreak++;
                        } else {
                            maxConsecutiveDaysOffFound = Math.max(maxConsecutiveDaysOffFound, currentConsecutiveDaysOffStreak);
                            currentConsecutiveDaysOffStreak = 0;
                        }
                    }
                }
                maxConsecutiveDaysOffFound = Math.max(maxConsecutiveDaysOffFound, currentConsecutiveDaysOffStreak);

                if (maxConsecutiveDaysOffFound < REQUIRED_DAYS_OFF_BETWEEN_TOURS) {
                    addBreach(`Consecutive Duty Tours Breach: Worked 6+ days (ending ${firstTour.end}) then another 6+ days (starting ${secondTour.start}) with only ${maxConsecutiveDaysOffFound} consecutive days off in between. Minimum ${REQUIRED_DAYS_OFF_BETWEEN_TOURS} consecutive days off required.`);
                }
            }

            // --- Rest Periods Between Duty Periods Check ---
            const HOME_BASE_MIN_REST_HOURS = 12;
            const HOME_BASE_MIN_REST_MINUTES = HOME_BASE_MIN_REST_HOURS * 60;

            for (let i = 0; i < roster.length - 1; i++) {
                const prevEntry = roster[i];
                const currentEntry = roster[i + 1];

                const isCurrentEntryDuty = !(
                    currentEntry.dutyType.toUpperCase().includes('RDO') ||
                    currentEntry.dutyType.toUpperCase().includes('GREY DAY') ||
                    currentEntry.dutyType.toUpperCase().includes('SBY') ||
                    currentEntry.dutyType.toUpperCase().includes('LEAVE')
                );

                if (isNaN(parseTime(prevEntry.debriefTime)) || isNaN(parseTime(currentEntry.briefTime)) || !isCurrentEntryDuty) {
                    continue;
                }

                const prevDebriefMinutes = parseTime(prevEntry.debriefTime);
                const currentBriefMinutes = parseTime(currentEntry.briefTime);

                let restDurationMinutes;
                if (currentBriefMinutes >= prevDebriefMinutes) {
                    restDurationMinutes = currentBriefMinutes - prevDebriefMinutes;
                } else {
                    restDurationMinutes = (24 * 60 - prevDebriefMinutes) + currentBriefMinutes;
                }
                
                const isPrevDutyAtHomeBase = prevEntry.layover.trim() === '';
                const isCurrentDutyAtHomeBase = currentEntry.layover.trim() === '';

                if (isPrevDutyAtHomeBase && isCurrentDutyAtHomeBase) {
                    if (restDurationMinutes < HOME_BASE_MIN_REST_MINUTES) {
                        addBreach(`Rest Period Breach (Home Base): Only ${formatMinutesToHHMM(restDurationMinutes)} rest between duties on ${prevEntry.dateString} (debrief: ${prevEntry.debriefTime}) and ${currentEntry.dateString} (brief: ${currentEntry.briefTime}). Minimum ${HOME_BASE_MIN_REST_HOURS} hours required at Home Base.`);
                    }
                } else {
                    if (restDurationMinutes < HOME_BASE_MIN_REST_MINUTES) {
                        addBreach(`Short Rest Period (Info): Only ${formatMinutesToHHMM(restDurationMinutes)} rest between duties on ${prevEntry.dateString} (debrief: ${prevEntry.debriefTime}) and ${currentEntry.dateString} (brief: ${currentEntry.briefTime}). This may be permissible if away from Home Base (e.g., 10-hour rule) or under specific FRMS limitations.`, true);
                    }
                }
            }


            // Display overall result
            if (breachesFound.length === 0) {
                const li = document.createElement('li');
                li.textContent = "No roster breaches found based on the implemented checks.";
                li.classList.add('no-breach');
                breachList.appendChild(li);
            }

            document.getElementById('breachResults').style.display = 'block';
        }

        // New functions for the modal/popover
        function showBreachInfoModal() {
            document.getElementById('breachInfoModal').style.display = 'flex';
        }

        function hideBreachInfoModal() {
            document.getElementById('breachInfoModal').style.display = 'none';
        }

        function generatePrintout() {
            let lines = document.getElementById('rosterInput').value.trim().split('\n');
            if (!lines.length) return alert("Paste your roster first.");
            lines = cleanHeaderLines(lines);

            const tbody = document.getElementById('printTableBody');
            const table = document.getElementById('printTable');
            tbody.innerHTML = '';

            const newBlockRegex = /^\d{2}\/\w{3}\/\d{4}[ \t]/;
            const timeSummaryRegex = /^\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}[ \t]+\d{1,2}:\d{2}$/;
            let buffer = [];
            let totals = [0, 0, 0, 0];

            function parseMinutes(time) {
                const [h, m] = time.split(':').map(Number);
                return h * 60 + m;
            }

            function formatMinutes(mins) {
                const h = Math.floor(mins / 60);
                const m = mins % 60;
                return `${h}:${m.toString().padStart(2, '0')}`;
            }

            function flushRow() {
                if (!buffer.length) return;

                const row = Array(10).fill('');
                const start = buffer[0].split(/\t| {2,}/);
                for (let i = 0; i < start.length && i < 5; i++) row[i] = start[i];

                const [dd, mon, yyyy] = row[0].split(/[\/\s]/);
                let currentYear = new Date().getFullYear();
                if (yyyy && !isNaN(Number(yyyy))) {
                    currentYear = Number(yyyy);
                }
                const months = {
                    Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
                    Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
                };
                const d = new Date(currentYear, months[mon], Number(dd));
                const dayOfWeek = d.toLocaleDateString('en-AU', { weekday: 'short' });
                const fullDay = d.toLocaleDateString('en-AU', { weekday: 'long' });
                row[0] = `${dayOfWeek} ${row[0]}`;
                const isWeekend = (fullDay === 'Saturday' || fullDay === 'Sunday');

                let summaryParts = [];
                let detailsLines = [];
                let foundSummary = false;
                for (let k = 1; k < buffer.length; k++) {
                    if (timeSummaryRegex.test(buffer[k])) {
                        summaryParts = buffer[k].split(/\t| {2,}/);
                        foundSummary = true;
                        break;
                    } else {
                        detailsLines.push(buffer[k]);
                    }
                }
                row[5] = detailsLines.join('\n');

                if (!foundSummary && detailsLines.length > 0) {
                     const lastDetailLine = detailsLines[detailsLines.length - 1];
                     if (timeSummaryRegex.test(lastDetailLine)) {
                        summaryParts = lastDetailLine.split(/\t| {2,}/);
                        detailsLines.pop();
                        row[5] = detailsLines.join('\n');
                     }
                }

                for (let i = 0; i < summaryParts.length; i++) row[6 + i] = summaryParts[i];

                for (let i = 6; i <= 9; i++) {
                    if (row[i].match(/^\d{1,2}:\d{2}$/)) {
                        totals[i - 6] += parseMinutes(row[i]);
                    }
                }

                const tr = document.createElement('tr');
                if (isWeekend) tr.classList.add('weekend-row');
                row.forEach(val => {
                    const td = document.createElement('td');
                    td.textContent = val;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
                buffer = [];
            }

            lines.forEach(line => {
                if (newBlockRegex.test(line)) flushRow();
                buffer.push(line);
            });
            flushRow();

            const summaryRow = document.createElement('tr');
            for (let i = 0; i < 10; i++) {
                const td = document.createElement('td');
                if (i === 0) td.textContent = 'TOTAL';
                if (i >= 6) td.textContent = formatMinutes(totals[i - 6]);
                summaryRow.appendChild(td);
            }
            summaryRow.style.fontWeight = 'bold';
            summaryRow.style.borderTop = '2px solid #000';
            tbody.appendChild(summaryRow);

            table.style.display = 'table';
            window.print();
        }
    </script>
</body>
</html>
